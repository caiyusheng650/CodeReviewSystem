name: wanan codereview

on:
  pull_request_target:
    types: [opened, synchronize, reopened]
  # å…è®¸ä»PRåˆ†æ”¯ç›´æ¥è§¦å‘ï¼Œå³ä½¿ç›®æ ‡åˆ†æ”¯æ²¡æœ‰æ­¤é…ç½®
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: read
  # æ·»åŠ å¿…è¦çš„æƒé™ä»¥å…è®¸ä»PRåˆ†æ”¯è¿è¡Œ
  actions: read

jobs:
  wanan-codereview:
    runs-on: ubuntu-latest

    steps:
      # 1) Checkout Repo
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2) Capture Metadata
      - name: Normalize PR Metadata
        id: meta
        run: |
          echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          echo "REPO_OWNER=${{ github.repository_owner }}" >> $GITHUB_ENV
          echo "REPO_NAME=${{ github.event.pull_request.head.repo.name }}" >> $GITHUB_ENV
          echo "AUTHOR=${{ github.actor }}" >> $GITHUB_ENV
          echo "RUN_ID=${{ github.run_id }}" >> $GITHUB_ENV
          echo "RUN_ATTEMPT=${{ github.run_attempt }}" >> $GITHUB_ENV
          echo "RUN_NUMBER=${{ github.run_number }}" >> $GITHUB_ENV

          # Base64 encoding of title/body
          printf "%s" "${{ github.event.pull_request.title }}" | base64 -w0 > title.b64
          printf "%s" "${{ github.event.pull_request.body }}" | base64 -w0 > body.b64

      # 3) Capture README Content
      - name: Capture README Content
        run: |
          # æ£€æŸ¥ README.md æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿›è¡Œç¼–ç ï¼Œå¦åˆ™åˆ›å»ºä¸€ä¸ªç©ºæ–‡ä»¶
          if [ -f "README.md" ]; then
            echo "README.md found. Encoding content."
            printf "%s" "$(cat README.md)" | base64 -w0 > readme.b64
          else
            echo "README.md not found. Creating empty placeholder file."
            touch readme.b64
          fi

      # 4) Generate diff safely
      - name: Generate diff safely
        run: |
          BASE="${{ github.base_ref }}"
          if [ -z "$BASE" ]; then BASE="main"; fi
          
          # åœ¨pull_request_targetäº‹ä»¶ä¸­ï¼ŒHEADæŒ‡å‘ç›®æ ‡åˆ†æ”¯ï¼Œéœ€è¦è·å–PRåˆ†æ”¯çš„SHA
          PR_HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          
          # ä½¿ç”¨PRåˆ†æ”¯SHAä¸ç›®æ ‡åˆ†æ”¯è¿›è¡Œdiffæ¯”è¾ƒ
          DIFF_RAW=$(git diff -U3 "origin/$BASE"..."$PR_HEAD_SHA")

          # Prevent oversize
          DIFF_SIZE=$(echo "$DIFF_RAW" | wc -c)
          MAX=5000000
          if [ "$DIFF_SIZE" -gt "$MAX" ]; then
            echo "âš ï¸ Diff >5MB, truncating."
            DIFF_RAW=$(echo "$DIFF_RAW" | head -c $MAX)
          fi

          printf "%s" "$DIFF_RAW" | base64 -w0 > diff.b64

      # 5) Fetch Existing Comments
      - name: Fetch Existing Comments
        run: |
          echo "Fetching existing PR review comments for context..."
          # Fetch all review comments, keeping only relevant fields for the AI
          COMMENTS_JSON=$(gh api \
            repos/${{ github.repository }}/pulls/${{ env.PR_NUMBER }}/comments \
            --jq '[.[] | {id: .id, user: .user.login, body: .body, path: .path, line: .line}]')
          
          # Base64 encode the comments JSON
          printf "%s" "$COMMENTS_JSON" | base64 -w0 > comments.b64
          echo "Comments JSON encoded into comments.b64."
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # ä½¿ç”¨å†…ç½®çš„ GITHUB_TOKEN è¿›è¡Œ API è®¿é—®

      # 6) Build JSON Payload
      - name: Build JSON Payload
        run: |
          cat <<EOF > payload.json
          {
            "githubactionid" : "${{ env.RUN_ID }}",
            "diff_base64": "$(cat diff.b64)",
            "pr_number": "${{ env.PR_NUMBER }}",
            "pr_title_b64": "$(cat title.b64)",
            "pr_body_b64": "$(cat body.b64)",
            "readme_b64": "$(cat readme.b64)",
            "repo_owner": "${{ env.REPO_OWNER }}",
            "repo_name": "${{ env.REPO_NAME }}",
            "author": "${{ env.AUTHOR }}",
            "comments_b64": "$(cat comments.b64)"
          }
          EOF
          
          echo "=== API Payload (payload.json) ==="
          cat payload.json
          echo "=================================="

      # 7) Submit Review Task (Async)
      - name: Submit Review Task
        id: submit_task
        run: |
          echo "ä½¿ç”¨çš„API URL: ${{ secrets.CODE_REVIEW_API_URL }}"
          
          # æäº¤å¼‚æ­¥ä»»åŠ¡
          curl -v -X POST \
            -H "X-Api-Key: ${{ secrets.CODE_REVIEW_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data-binary @payload.json \
            "${{ secrets.CODE_REVIEW_API_URL }}/api/codereview/submit" \
            -o task_response.json

          echo "=== Task Submission Response ==="
          cat task_response.json
          echo "================================"
          
          # æå–ä»»åŠ¡ID
          TASK_ID=$(jq -r '.task_id' task_response.json)
          echo "TASK_ID=$TASK_ID" >> $GITHUB_ENV
          echo "Task ID: $TASK_ID"

      # 8) Poll for Task Completion
      - name: Poll for Task Completion
        id: poll_task
        run: |
          MAX_POLLS=60  # æœ€å¤§è½®è¯¢æ¬¡æ•°ï¼ˆ60æ¬¡ * 30ç§’ = 30åˆ†é’Ÿï¼‰
          POLL_INTERVAL=30  # è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰
          
          for i in $(seq 1 $MAX_POLLS); do
            echo "Polling attempt $i/$MAX_POLLS..."
            
            # æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
            curl -s -X GET \
              -H "X-Api-Key: ${{ secrets.CODE_REVIEW_API_TOKEN }}" \
              "${{ secrets.CODE_REVIEW_API_URL }}/api/codereview/status/${{ env.TASK_ID }}" \
              -o status_response.json
            
            STATUS=$(jq -r '.status' status_response.json)
            echo "Current status: $STATUS"
            
            case $STATUS in
              "completed")
                echo "âœ… Task completed successfully!"
                # ç›´æ¥ä»çŠ¶æ€å“åº”ä¸­æå–ç»“æœï¼Œæ— éœ€å†è°ƒç”¨/resultæ¥å£
                jq '.result' status_response.json > response.json
                
                echo "=== Final Response ==="
                cat response.json
                echo "====================="
                exit 0
                ;;
              "failed")
                echo "âŒ Task failed!"
                ERROR_MSG=$(jq -r '.error' status_response.json)
                echo "Error: $ERROR_MSG"
                exit 1
                ;;
              "processing")
                echo "â³ Task still processing..."
                sleep $POLL_INTERVAL
                ;;
              "pending")
                echo "â³ Task still pending..."
                sleep $POLL_INTERVAL
                ;;
              *)
                echo "â“ Unknown status: $STATUS"
                sleep $POLL_INTERVAL
                ;;
            esac
          done
          
          # å¦‚æœè¾¾åˆ°æœ€å¤§è½®è¯¢æ¬¡æ•°ä»æœªå®Œæˆ
          echo "âŒ Timeout: Task did not complete within $((MAX_POLLS * POLL_INTERVAL / 60)) minutes"
          exit 1

      # 9) Format markdown
      - name: Generate Review Markdown
        run: |
          # é¦–å…ˆæ ¹æ®ä¸¥é‡ç¨‹åº¦ç”Ÿæˆconclusion
          jq '
            .conclusion = (
              if (.issues | to_entries | map(.value.severity) | any(. == "ä¸¥é‡" or . == "ä¸­ç­‰")) 
              then "ä¸å»ºè®®åˆå¹¶" 
              else "å»ºè®®åˆå¹¶" 
              end
            )
          ' response.json > temp.json && mv temp.json response.json
          
          # ç„¶åç”ŸæˆMarkdownï¼ˆé‡ç‚¹å¤„ç†å†å²æœªä¿®å¤é—®é¢˜ï¼‰
          jq -r '
            "## ğŸ¤– AI ä»£ç å®¡æŸ¥æ„è§\n" +
            "**åˆå¹¶å»ºè®®**: \(.conclusion)\n\n" +
            "### é—®é¢˜åˆ—è¡¨\n" +
            (
              .issues | to_entries | map(
                # å¯¹å†å²æœªä¿®å¤é—®é¢˜æ·»åŠ é†’ç›®æ ‡è¯†
                (if .value.historical_mention == true then "âš ï¸ **[å†å²æœªä¿®å¤é—®é¢˜]**\n" else "" end) +
                "- **æ–‡ä»¶**: " + .value.file +
                " (è¡Œ " + (.value.line|tostring) + ")\n" +
                "  - ç±»å‹: **" + .value.bug_type + "**\n" +
                "  - ç¨‹åº¦: **" + .value.severity + "**\n" +
                # å†å²é—®é¢˜è¡¥å……æç¤ºæ–‡å­—
                (if .value.historical_mention == true then "  - æç¤º: æ­¤é—®é¢˜å·²åœ¨å†å²å®¡æŸ¥ä¸­å¤šæ¬¡æåŠï¼Œè¯·ä¼˜å…ˆä¿®å¤\n" else "" end) +
                "  - æè¿°: " + .value.description + "\n" +
                "  - å»ºè®®: " + .value.suggestion + "\n"
              ) | join("\n")
            )
          ' response.json > comment.md

          echo "Markdown generated:"
          cat comment.md


      # 10) Add inline comments
      - name: Add inline comments
        run: |
          # åœ¨pull_request_targetäº‹ä»¶ä¸­ï¼Œåº”è¯¥ä½¿ç”¨PRåˆ†æ”¯çš„SHAè€Œä¸æ˜¯ç›®æ ‡åˆ†æ”¯çš„SHA
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          echo "HEAD_SHA=$HEAD_SHA"

          jq -c '.issues[]' response.json | while read -r issue; do
            file=$(echo "$issue" | jq -r '.file')
            line=$(echo "$issue" | jq -r '.line')
            type=$(echo "$issue" | jq -r '.bug_type')
            desc=$(echo "$issue" | jq -r '.description')
            sug=$(echo "$issue" | jq -r '.suggestion')
            sev=$(echo "$issue" | jq -r '.severity')
            # æå–å†å²æœªä¿®å¤æ ‡è®°
            historical=$(echo "$issue" | jq -r '.historical_mention')

            # å¯¹å†å²æœªä¿®å¤é—®é¢˜æ·»åŠ ç‰¹æ®Šå‰ç¼€å’Œæç¤º
            if [ "$historical" = "true" ]; then
              header="**AI ä»£ç å®¡æŸ¥æ„è§**"
              extra_note=$'\n**æç¤º**: æ­¤é—®é¢˜å·²åœ¨å†å²å®¡æŸ¥ä¸­å¤šæ¬¡æåŠï¼Œè¯·ä¼˜å…ˆå¤„ç†'
            else
              header="**AI ä»£ç å®¡æŸ¥æ„è§**"
              extra_note=""
            fi

            # æ‹¼æ¥è¯„è®ºå†…å®¹ï¼ˆåŒ…å«å†å²é—®é¢˜æ ‡è¯†ï¼‰
            body=$(printf "%s\n**ç±»å‹**: %s\n**æè¿°**: %s\n**å»ºè®®**: %s\n**ç¨‹åº¦**: %s%s" \
              "$header" "$type" "$desc" "$sug" "$sev" "$extra_note")

            echo "Attempting to add inline comment to $file:$line"

            # ä¿ç•™åŸæœ‰çš„é”™è¯¯å¤„ç†é€»è¾‘
            if ! gh api \
              repos/${{ github.repository }}/pulls/${{ env.PR_NUMBER }}/comments \
              -X POST \
              -f body="$body" \
              -f commit_id="$HEAD_SHA" \
              -f path="$file" \
              -F line="$line" > /dev/null 2>&1
            then
              echo "âŒ ERROR: Failed to add inline comment to $file:$line"
            else
              echo "âœ… Success: Added inline comment to $file:$line"
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 11) Create Summary Comment
      - name: Create or update summary comment
        uses: peter-evans/create-or-update-comment@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ env.PR_NUMBER }}
          body-file: comment.md
          edit-mode: replace